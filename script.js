// This file was generated by Slater.app - achivement_slider.js


window.Webflow ||= [];
window.Webflow.push(() => {
  gsap.config({ nullTargetWarn: false });

  $(".section_achivement").each(function () {
    const $slider = $(this);

    // ============================================
    // S√âLECTEURS
    // ============================================
    const $contentWrapper = $slider.find("[data-content-wrapper]");
    const $items = $slider.find("[data-image-item='']").hide();
    const $itemsLogo = $slider.find("[data-image-item='2']").hide();
    const $itemsButton = $slider.find(".achivement_slider-button-item").hide();
    const $dots = $slider.find("[data-dot-item]");
    const $homeSlider = $slider.find("[data-slider]");
    const $arrow = $slider.find("[data-arrow='']");
    const $arrowLeftHide = $slider.find("[data-arrow='left-hide']");
    const $arrowRightHide = $slider.find("[data-arrow='right-hide']");
    const $dotList = $slider.find("[data-dot-list]");
    const $headings = $slider.find(".home-slider_heading");
    const $triggerWrapper = $slider.find("[data-trigger-wrapper]");
    const $contentTop = $slider.find("[data-content-top='']");

    // ============================================
    // VARIABLES
    // ============================================
    const totalSlides = $items.length;
    let activeIndex = 0;
    let currentX = 0,
      currentY = 0,
      targetX = 0,
      targetY = 0;
    let dotTimeline;

    // ============================================
    // INITIALISATION
    // ============================================
    $itemsLogo.hide().first().css('display', 'flex');
    $itemsButton.hide().first().css('display', 'flex');
    $items.first().css("display", "flex");
    $('.achivement_slider-collection-item').removeClass('active').first().addClass(
      'active');
    gsap.set($dots.eq(0).find(".slider_dot_line"), { scaleX: 1 });
    $('.achivement_slider-para-item').removeClass('active').first().addClass('active');
    $('.achivement_slider-button-item').removeClass('active').first().addClass('active');

    // ============================================
    // TIMELINE DES POINTS
    // ============================================
    dotTimeline = gsap.timeline({ repeat: -1 });
    $dots.each((index, dot) => {
      dotTimeline.addLabel(`step${index}`);
      dotTimeline.to($(dot).find(".home-slider_dot-line"), {
        scaleX: 1,
        ease: "none",
        duration: 8,
        onComplete: () => goToSlide((index + 1) % totalSlides, true),
      });
    });

    // ============================================
    // NAVIGATION VERS UN SLIDE
    // ============================================
    function goToSlide(nextIndex, forwards) {
      if (nextIndex === activeIndex) return;

      const $prevItem = $items.eq(activeIndex);
      const $nextItem = $items.eq(nextIndex);
      const $prevLogo = $itemsLogo.eq(activeIndex);
      const $nextLogo = $itemsLogo.eq(nextIndex);
      const $prevButton = $itemsButton.eq(activeIndex);
      const $nextButton = $itemsButton.eq(nextIndex);

      // Mettre √† jour les points
      gsap.to($dots.find(".slider_dot_line"), { scaleX: 0, duration: 0.3 });
      gsap.to($dots.eq(nextIndex).find(".slider_dot_line"), { scaleX: 1, duration: 0.3 });

      // Pr√©parer l'affichage
      $items.hide();
      $prevItem.css("display", "flex");
      $nextItem.css("display", "flex");

      $itemsLogo.hide();
      $prevLogo.css("display", "flex");
      $nextLogo.css("display", "flex");

      $itemsButton.hide();
      $prevButton.css("display", "flex");
      $nextButton.css("display", "flex");

      // Activer l'√©l√©ment et animer le titre
      const $firstList = $slider.find('.achivement_slider-collection-list').eq(0);
      $firstList.find('.achivement_slider-collection-item').removeClass('active');
      const $activeItem = $firstList.find('.achivement_slider-collection-item').eq(
        nextIndex).addClass('active');
      const $activeTitle = $activeItem.find('.achivement_slider-heading');

      if ($activeTitle.length) {
        const text = $activeTitle.text();
        $activeTitle.html(text.split('').map(char => `<span class="char">${char}</span>`)
          .join(''));
        gsap.fromTo($activeTitle.find('.char'), { y: 60, opacity: 0 }, {
          y: 0,
          opacity: 1,
          duration: 0.7,
          stagger: { amount: 0.4 },
          ease: "power2.out"
        });
      }

      // Deuxi√®me liste : activer et animer le paragraphe
      const $secondList = $slider.find('.achivement_slider-collection-list').eq(1);
      $secondList.find('.achivement_slider-para-item').removeClass('active');
      const $activeParaItem = $secondList.find('.achivement_slider-para-item').eq(nextIndex)
        .addClass('active');
      const $activePara = $activeParaItem.find('.achivement_slider-para');

      if ($activePara.length) {
        const paraText = $activePara.text();
        $activePara.html(paraText.split('').map(char => `<span class="char">${char}</span>`)
          .join(''));
        gsap.fromTo($activePara.find('.char'), { y: 60, opacity: 0 }, {
          y: 0,
          opacity: 1,
          duration: 0.7,
          stagger: { amount: 0.4 },
          ease: "power2.out",
          delay: 0.3
        });
      }

      // Activer le bouton correspondant
      $('.achivement_slider-button-item').removeClass('active');
      $('.achivement_slider-button-item').eq(nextIndex).addClass('active');

      // D√©finir les clip-paths
      const clipPathFrom = forwards ? {
        next: "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)",
        prev: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
      } : {
        next: "polygon(100% 0%, 100% 0%, 100% 100%, 100% 100%)",
        prev: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
      };

      const clipPathTo = forwards ? {
        next: "polygon(0% 0%, 100% 0%, 130% 100%, 0% 100%)",
        prev: "polygon(100% 0%, 100% 0%, 100% 100%, 130% 100%)",
      } : {
        next: "polygon(0% 0%, 100% 0%, 100% 100%, -30% 100%)",
        prev: "polygon(0% 0%, 0% 0%, -30% 100%, 0% 100%)",
      };

      // Timeline de transition
      const tl = gsap.timeline({ defaults: { duration: 1, ease: "power2.inOut" } });

      // Forcer la position de d√©part des boutons
      $nextButton.css("display", "flex");
      $prevButton.css("display", "flex");

      gsap.set($nextButton, {
        opacity: 0,
        x: forwards ? "-100%" : "100%",
        y: 0,
        clearProps: "transform,translate,rotate,filter,scale"
      });
      gsap.set($prevButton, {
        opacity: 1,
        x: 0,
        y: 0,
        clearProps: "transform,translate,rotate,filter,scale"
      });

      tl.fromTo($nextItem, { clipPath: clipPathFrom.next }, { clipPath: clipPathTo.next });
      tl.fromTo($prevItem, { clipPath: clipPathFrom.prev }, { clipPath: clipPathTo.prev },
        "<");
      tl.fromTo($nextLogo, { clipPath: clipPathFrom.next }, { clipPath: clipPathTo.next },
        "<");
      tl.fromTo($prevLogo, { clipPath: clipPathFrom.prev }, { clipPath: clipPathTo.prev },
        "<");

      tl.fromTo($nextButton, { opacity: 0, x: forwards ? "-50%" : "50%" }, {
          opacity: 1,
          x: 0,
          duration: 1,
          y: "0%"
        },
        "<"
      );
      tl.to($prevButton, { opacity: 0, x: forwards ? "50%" : "-50%", y: "0%", duration: 1 },
        "<"
      );

      const titleFrom = forwards ? 100 : -100;
      const titleDelay = forwards ? "<50%" : "<";
      tl.fromTo($nextItem.find(
          ".home-slider_title .char"), { yPercent: titleFrom }, {
          yPercent: 0,
          duration: 0.5,
          stagger: { amount: 0.5 }
        },
        titleDelay
      );

      activeIndex = nextIndex;
      dotTimeline.seek(`step${nextIndex}`);
    }

    // ============================================
    // UTILITAIRES
    // ============================================
    const isDesktop = () => window.innerWidth >= 992;

    const isCursorOver = (e, $element) => {
      const rect = $element[0].getBoundingClientRect();
      return e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top && e.clientY <= rect.bottom;
    };

    // ============================================
    // √âV√âNEMENTS
    // ============================================
    $contentWrapper.on("click", function (event) {
      if ($(event.target).closest(".button, .navbar_menu-wrap, [data-dot-item]").length)
        return;
      const rect = this.getBoundingClientRect();
      const isLeftSide = event.clientX - rect.left < rect.width / 2;
      goToSlide((activeIndex + (isLeftSide ? -1 : 1) + totalSlides) % totalSlides, !
        isLeftSide);
    });

    $dots.on("click", function () {
      const dotIndex = $(this).index();
      goToSlide(dotIndex, dotIndex > activeIndex);
    });

    // ============================================
    // ANIMATION DE LA FL√àCHE
    // ============================================
    let isOverInteractiveElement = false;
    let isInsideCard = true; // Initialiser √† true pour afficher la fl√®che au chargement

    function updateArrowPosition() {
      if (!isDesktop()) {
        return;
      }

      currentX += (targetX - currentX) * 0.1;
      currentY += (targetY - currentY) * 0.1;

      const rect = $homeSlider[0].getBoundingClientRect();
      const isLeftSide = currentX < rect.width / 2;

      // Si on survole un √©l√©ment interactif, ne pas bouger la fl√®che
      if (isOverInteractiveElement) {
        requestAnimationFrame(updateArrowPosition);
        return;
      }

      // Si on est en dehors de la card, ne pas changer les opacit√©s
      if (!isInsideCard) {
        requestAnimationFrame(updateArrowPosition);
        return;
      }

      if (isLeftSide) {
        // C√¥t√© gauche - fl√®che normale
        const arrowWidth = $arrow.width();
        $arrow.css({
          left: `${currentX - arrowWidth}px`,
          top: `${currentY}px`,
          transform: `translate(0, -50%) rotate(0deg)`,
        });

        // Cacher left-hide et afficher right-hide
        gsap.to($arrowLeftHide, { opacity: 0, duration: 0.3 });
        gsap.to($arrowRightHide, { opacity: 1, duration: 0.3 });
      } else {
        // C√¥t√© droit - fl√®che √† 180¬∞
        const arrowWidth = $arrow.width();
        $arrow.css({
          left: `${currentX + arrowWidth}px`,
          top: `${currentY}px`,
          transform: `translate(-100%, -50%) rotate(180deg)`,
        });

        // Cacher right-hide et afficher left-hide
        gsap.to($arrowRightHide, { opacity: 0, duration: 0.3 });
        gsap.to($arrowLeftHide, { opacity: 1, duration: 0.3 });
      }

      requestAnimationFrame(updateArrowPosition);
    }

    $homeSlider.on("mousemove", function (e) {
      if (!isDesktop()) return;

      const rect = $homeSlider[0].getBoundingClientRect();
      targetX = e.clientX - rect.left;
      targetY = e.clientY - rect.top;

      const isOverDotList = isCursorOver(e, $dotList);
      const isOverHeadings = $headings.toArray().some((heading) => isCursorOver(e, $(
        heading)));
      const isOverTriggerWrapper = $triggerWrapper.toArray().some((trigger) =>
        isCursorOver(e, $(trigger)));
      const isOverContentTop = isCursorOver(e, $contentTop);

      isOverInteractiveElement = isOverDotList || isOverHeadings ||
        isOverTriggerWrapper || isOverContentTop;

      if (isOverInteractiveElement) {
        gsap.to($arrow, {
          opacity: 0,
          duration: 0.3,
          ease: "power2.out"
        });
      } else {
        gsap.to($arrow, {
          opacity: 1,
          duration: 0.3,
          ease: "power2.out"
        });
      }
    });

    $homeSlider.on("mouseleave", () => {
      if (!isDesktop()) return;

      isInsideCard = false;

      gsap.to($arrow, {
        opacity: 0,
        duration: 0.3,
        ease: "power2.out"
      });

      gsap.to($arrowLeftHide, {
        opacity: 1,
        duration: 0.3,
        ease: "power2.out"
      });

      gsap.to($arrowRightHide, {
        opacity: 1,
        duration: 0.3,
        ease: "power2.out"
      });
    });

    $homeSlider.on("mouseenter", function (e) {
      if (!isDesktop()) return;

      isInsideCard = true;

      const rect = $homeSlider[0].getBoundingClientRect();
      currentX = targetX = e.clientX - rect.left;
      currentY = targetY = e.clientY - rect.top;

      // R√©afficher $arrow quand on entre dans la card
      gsap.to($arrow, {
        opacity: 1,
        duration: 0.3,
        ease: "power2.out"
      });
    });

    $headings.on("mouseenter", () => {
      gsap.to($arrow, {
        opacity: 0,
        duration: 0.3,
        ease: "power2.out"
      });
    });

    $headings.on("mouseleave", () => {
      gsap.to($arrow, {
        opacity: 1,
        duration: 0.3,
        ease: "power2.out"
      });
    });

    $(window).on("resize", () => {
      // Ne rien faire
    });

    updateArrowPosition();
  });
});


// This file was generated by Slater.app - component_btn.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {

  function initializeGSAPAnimations() {
    if (window.innerWidth <= 991) return;

    const wrappers = document.querySelectorAll('[data-trigger-wrapper=""]');

    wrappers.forEach(wrapper => {
      wrapper._animationRunning = false;
      wrapper._isHovered = false;

      // S√©lectionner les √©l√©ments relatifs et absolus pour texte et ic√¥nes
      const relTextEls = wrapper.querySelectorAll('[data-text-state="rel"]');
      const absTextEls = wrapper.querySelectorAll('[data-text-state="abs"]');
      const relIconEls = wrapper.querySelectorAll('[data-icon-state="rel"]');
      const absIconEls = wrapper.querySelectorAll('[data-icon-state="abs"]');

      // Initialiser les propri√©t√©s GSAP au d√©part
      gsap.set(relTextEls, { x: 0 });
      gsap.set(relIconEls, { x: 0, rotation: 0 });
      gsap.set(absTextEls, { x: "-120%" });
      gsap.set(absIconEls, { x: "-120%", rotation: 45 });

      function getXPosition(target, isEntering) {
        // Calculer la position X selon l'√©l√©ment et si on entre ou sort
        if ([...relIconEls].includes(target)) return isEntering ? "120%" : 0;
        if ([...absIconEls].includes(target)) return isEntering ? "0%" : "-120%";
        if ([...relTextEls].includes(target)) return isEntering ? "120%" : 0;
        if ([...absTextEls].includes(target)) return isEntering ? "0%" : "-120%";
      }

      wrapper.addEventListener("mouseenter", () => {
        console.log("mouseenter");
        wrapper._isHovered = true;
        if (wrapper._animationRunning) return;
        wrapper._animationRunning = true;

        const tlIn = gsap.timeline({
          onComplete: () => {
            wrapper._animationRunning = false;
            if (!wrapper._isHovered) {
              wrapper._animationRunning = true;
              const tlOut = gsap.timeline({
                onComplete: () => { wrapper._animationRunning = false; }
              });

              tlOut.to([...absTextEls, ...relTextEls, ...relIconEls, ...
                  absIconEls
                ], {
                  x: target => getXPosition(target, false),
                  duration: 1,
                  ease: "expo.inOut",
                  stagger: { each: 0.04, from: "end" }
                })
                .to(relIconEls, { rotation: 0, duration: 0.3, ease: "power2.in" },
                  "-=0.16")
                .to(absIconEls, {
                  rotation: 45,
                  duration: 0.3,
                  ease: "power2.in"
                }, "-=0.16");
            }
          }
        });

        tlIn.to(relIconEls, {
          rotation: 45,
          duration: 0.3,
          ease: "power1.out"
        });
        tlIn.to([...absTextEls, ...relTextEls, ...relIconEls, ...absIconEls], {
          x: target => getXPosition(target, true),
          duration: 1,
          ease: "expo.out",
          stagger: { each: 0.04, from: "start" }
        });
      });

      wrapper.addEventListener("mouseleave", () => {
        wrapper._isHovered = false;
        if (wrapper._animationRunning) return;
        wrapper._animationRunning = true;

        const tlOut = gsap.timeline({
          onComplete: () => { wrapper._animationRunning = false; }
        });

        tlOut.to([...absTextEls, ...relTextEls, ...relIconEls, ...absIconEls], {
            x: target => getXPosition(target, false),
            duration: 1,
            ease: "expo.inOut",
            stagger: { each: 0.04, from: "end" }
          })
          .to(relIconEls, { rotation: 0, duration: 0.3, ease: "power2.in" }, "-=0.16")
          .to(absIconEls, { rotation: 45, duration: 0.3, ease: "power2.in" }, "-=0.16");
      });

    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => setTimeout(initializeGSAPAnimations,
      100));
  } else {
    setTimeout(initializeGSAPAnimations, 100);
  }
});


// This file was generated by Slater.app - faq_dropdown.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  document.querySelectorAll('.faq_item-wrapper').forEach(item => {
    item.addEventListener('click', function () {
      const radials = this.querySelectorAll('.faq_radial');
      radials.forEach(radial => {
        // Flag JS pour ignorer si anim en cours
        if (radial.dataset.animating === "true") return;

        let count = +(radial.dataset.animCount || 0);
        count++;
        radial.dataset.animCount = count;
        radial.dataset.animating = "true";

        if (radial.classList.contains('is-top-left')) {
          if (count % 2 === 1) {
            radial.style.setProperty('--faqAnimLeft',
              'radialLeft 2s linear forwards');
          } else {
            radial.style.setProperty('--faqAnimLeft',
              'radialLeftReverse 2s linear forwards');
          }
          radial.addEventListener('animationend', () => {
            radial.dataset.animating = "false";
          }, { once: true });
        }
        if (radial.classList.contains('is-bottom-right')) {
          if (count % 2 === 1) {
            radial.style.setProperty('--faqAnimRight',
              'radialRight 2s linear forwards');
          } else {
            radial.style.setProperty('--faqAnimRight',
              'radialRightReverse 2s linear forwards');
          }
          radial.addEventListener('animationend', () => {
            radial.dataset.animating = "false";
          }, { once: true });
        }
      });
    });
  });
});





// This file was generated by Slater.app - faq_question.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {

const items = document.querySelectorAll('.faq_item-wrapper');

items.forEach(item => {
  const answer = item.querySelector('.faq_answer-wrapper');

  item.addEventListener('click', () => {
    if (item.classList.contains('active')) {
      // Animation fermeture
      answer.style.height = answer.scrollHeight + 'px'; // remet temporairement la hauteur r√©elle pour transition
      requestAnimationFrame(() => {
        answer.style.height = '0px';
      });
      item.classList.remove('active');

      answer.addEventListener('transitionend', function handler() {
        answer.style.removeProperty('height');
        answer.removeEventListener('transitionend', handler);
      });

    } else {
      // Animation ouverture
      answer.style.height = '0px'; // reset avant ouverture
      item.classList.add('active');
      requestAnimationFrame(() => {
        answer.style.height = answer.scrollHeight + 'px';
      });

      answer.addEventListener('transitionend', function handler() {
        if (item.classList.contains('active')) {
          answer.style.height = 'auto';
        }
        answer.removeEventListener('transitionend', handler);
      });
    }
  });
});


});

// This file was generated by Slater.app - navbar_add-scrool.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  const navbarContainer = document.querySelector(".navbar_container");
  const navbarComponent = document.querySelector(".navbar_component");
  const navbarContainerWrapper = document.querySelector(".navbar_container-wrapper");

  let lastScrollY = window.scrollY;
  let navbarHidden = false;
  let scrollAccumulator = 0;
  let blockNavbarShow = false;

  // Ajouter la transition au chargement
  if (navbarComponent) {
    navbarComponent.style.transition = "top 0.6s ease-out";
  }

  // D√©tecter le clic sur les √©l√©ments avec data-link-nav
  document.addEventListener("click", function (e) {
    const target = e.target.closest("[data-link-nav]");
    if (target && navbarComponent) {
      navbarComponent.style.top = "-20%";
      navbarHidden = true;
      scrollAccumulator = 0;
      blockNavbarShow = true;
    }
  });

  function handleScroll() {
    const currentScrollY = window.scrollY;
    const isAtTop = currentScrollY <= 0;
    const isAt1200 = currentScrollY >= 1200;

    // Gestion des classes scroll de base
    if (navbarContainer) {
      if (isAtTop) {
        navbarContainer.classList.remove("scroll");
      } else {
        navbarContainer.classList.add("scroll");
      }
    }

    if (navbarComponent) {
      if (isAtTop) {
        navbarComponent.classList.remove("scroll");
      } else {
        navbarComponent.classList.add("scroll");
      }
    }

    // Logique pour navbar_container-wrapper sans scroll-3
    if (navbarContainerWrapper) {
      if (isAtTop) {
        navbarContainerWrapper.classList.remove("scroll");
      } else {
        navbarContainerWrapper.classList.add("scroll");
      }
    }

    // Logique pour navbar_component √† partir de 1200px
    if (isAt1200 && navbarComponent) {
      const scrollDifference = currentScrollY - lastScrollY;

      // Si on scroll vers le bas, r√©initialiser l'accumulateur et cacher
      if (scrollDifference > 0) {
        scrollAccumulator = 0;
        blockNavbarShow = false;
        if (!navbarHidden) {
          navbarComponent.style.top = "-20%";
          navbarHidden = true;
        }
      }
      // Si on scroll vers le haut
      else if (scrollDifference < 0 && !blockNavbarShow) {
        scrollAccumulator += Math.abs(scrollDifference);

        // Si on a scroll√© 25px ou plus vers le haut
        if (scrollAccumulator >= 25 && navbarHidden) {
          navbarComponent.style.top = "0%";
          navbarHidden = false;
          scrollAccumulator = 0;
        }
      }
    } else if (navbarComponent && currentScrollY < 1200) {
      // R√©initialiser si on est en dessous de 1200px
      navbarComponent.style.top = "";
      navbarHidden = false;
      scrollAccumulator = 0;
      blockNavbarShow = false;
    }

    lastScrollY = currentScrollY;
  }

  window.addEventListener("scroll", handleScroll);
  handleScroll();
});


// This file was generated by Slater.app - navbar_link.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
document.querySelectorAll('.navbar_link-wrapper').forEach(link => {
  const arrow = link.querySelector('.navbar_navigation-arrow');
  const text = link.querySelector('.navbar_navigation-text-wrap');
  
  // V√©rifier que les √©l√©ments existent
  if (!arrow || !text) return;
  
  // Variables de gestion d'√©tat (propres √† chaque lien)
  let isHovered = false;
  let animationTimeout = null;
  let isAnimating = false;
  let pendingLeave = false;
  
  // Sauvegarder le padding initial
  const initialPadding = window.getComputedStyle(text).paddingRight;
  
  // √âtat initial
  arrow.style.position = 'absolute';
  arrow.style.bottom = '-100%';
  arrow.style.right = '-35%';
  arrow.style.transform = 'rotate(90deg)';
  arrow.style.transition =
    'bottom 0.8s cubic-bezier(0.22, 1, 0.36, 1), right 0.8s cubic-bezier(0.22, 1, 0.36, 1), transform 0.8s cubic-bezier(0.22, 1, 0.36, 1)';
  text.style.transition = 'padding-right 0.8s cubic-bezier(0.22, 1, 0.36, 1)';
  
  function startEnterAnimation() {
    isAnimating = true;
    pendingLeave = false;
    
    arrow.style.bottom = 'auto';
    arrow.style.right = '0%';
    arrow.style.transform = 'rotate(0deg)';
    text.style.paddingRight = '34px';
    
    // Marquer la fin de l'animation
    setTimeout(() => {
      isAnimating = false;
      
      // Si l'utilisateur a hover out pendant l'animation, lancer l'animation de sortie
      if (pendingLeave) {
        pendingLeave = false;
        startLeaveAnimation();
      }
    }, 800);
  }
  
  function startLeaveAnimation() {
    isAnimating = true;
    
    // D'abord translateX(200%)
    arrow.style.transform = 'rotate(0deg) translateX(200%)';
    
    // Ensuite remettre le padding initial et repositionner la fl√®che
    animationTimeout = setTimeout(() => {
      if (!isHovered) {
        text.style.paddingRight = initialPadding;
        arrow.style.bottom = '-100%';
        arrow.style.right = '-35%';
        arrow.style.transform = 'rotate(90deg)';
      }
      
      // Attendre la fin de toutes les transitions
      setTimeout(() => {
        isAnimating = false;
        
        // Si l'utilisateur a hover pendant l'animation, lancer l'animation d'entr√©e
        if (isHovered) {
          startEnterAnimation();
        }
      }, 800);
      
      animationTimeout = null;
    }, 800);
  }
  
  link.addEventListener('mouseenter', () => {
    isHovered = true;
    
    // Si une animation est en cours, marquer qu'on veut entrer apr√®s
    if (isAnimating) {
      pendingLeave = false;
      return;
    }
    
    startEnterAnimation();
  });
  
  link.addEventListener('mouseleave', () => {
    isHovered = false;
    
    // Si une animation d'entr√©e est en cours, marquer qu'on veut sortir apr√®s
    if (isAnimating) {
      pendingLeave = true;
      return;
    }
    
    startLeaveAnimation();
  });
});
});

// This file was generated by Slater.app - pause_hero_marquee.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les √©l√©ments marquee
  const marqueeElements = document.querySelectorAll('[data-marquee-logo]');

  if (marqueeElements.length > 0) {
    // console.log(`üëÄ ${marqueeElements.length} √©l√©ment(s) marquee trouv√©(s)`);

    const heroElement = document.querySelector('#hero');

    if (heroElement) {
      // Configurer l'IntersectionObserver pour #hero
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // console.log('‚ñ∂Ô∏è #hero est visible - Animation marquee reprend');

            // Reprendre les animations
            marqueeElements.forEach(element => {
              element.style.animationPlayState = 'running';
            });

          } else {
            // console.log('‚è∏Ô∏è #hero n\'est plus visible - Animation marquee en pause');

            // Mettre en pause les animations
            marqueeElements.forEach(element => {
              element.style.animationPlayState = 'paused';
            });
          }
        });
      }, {
        rootMargin: '0px',
        threshold: 0.1
      });

      observer.observe(heroElement);
      // console.log('üëÄ Observer activ√© pour #hero (marquee)');
    } else {
      console.log('‚ùå √âl√©ment #hero non trouv√©');
    }
  } else {
    console.log('‚ùå Aucun √©l√©ment marquee trouv√©');
  }
});


// This file was generated by Slater.app - pause_price_gear.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les engrenages
  const gears = document.querySelectorAll('.price_svg-gear-wrap');

  if (gears.length > 0) {
    // console.log(`‚öôÔ∏è ${gears.length} engrenage(s) trouv√©(s)`);

    let isAnimating = false;

    function pauseAnimations() {
      // console.log('‚è∏Ô∏è #price n\'est plus visible - Animations des engrenages en pause');
      gears.forEach(gear => {
        gear.style.animationPlayState = 'paused';
      });
      isAnimating = false;
    }

    function resumeAnimations() {
      // console.log('üé¨ #price est visible - Animations des engrenages reprises');
      gears.forEach(gear => {
        gear.style.animationPlayState = 'running';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #price
    const priceElement = document.querySelector('#price');

    if (priceElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            resumeAnimations();
          } else {
            pauseAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(priceElement);
      // console.log('üëÄ Observer activ√© pour #price (engrenages)');
    } else {
      console.log('‚ùå √âl√©ment #price non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      gears.forEach(gear => {
        gear.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        gears.forEach(gear => {
          gear.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun engrenage trouv√©');
  }
});


// This file was generated by Slater.app - pause_reviews_marquee.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les marquees de reviews
  const marquees = document.querySelectorAll('[data-marquee-reviews]');

  if (marquees.length > 0) {
    // console.log(`üëÄ ${marquees.length} marquee(s) de reviews trouv√©(s)`);

    let isAnimating = false;

    function pauseAnimations() {
      // console.log('‚è∏Ô∏è #reviews n\'est plus visible - Animations marquee en pause');
      marquees.forEach(marquee => {
        marquee.style.animationPlayState = 'paused';
      });
      isAnimating = false;
    }

    function resumeAnimations() {
      // console.log('üé¨ #reviews est visible - Animations marquee reprises');
      marquees.forEach(marquee => {
        marquee.style.animationPlayState = 'running';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #reviews
    const reviewsElement = document.querySelector('#reviews');

    if (reviewsElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            resumeAnimations();
          } else {
            pauseAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(reviewsElement);
      // console.log('üëÄ Observer activ√© pour #reviews (marquees)');
    } else {
      console.log('‚ùå √âl√©ment #reviews non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      marquees.forEach(marquee => {
        marquee.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        marquees.forEach(marquee => {
          marquee.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun marquee de reviews trouv√©');
  }
});


// This file was generated by Slater.app - reset_achivement_slider.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // Attendre que le slider soit initialis√©
  setTimeout(() => {
    const achievementElement = document.querySelector('#achivement');
    const sliderSection = document.querySelector('.section_achivement');

    if (achievementElement && sliderSection) {
      // console.log('üëÄ Section #achivement trouv√©e');

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // console.log('‚ñ∂Ô∏è #achivement est visible - Animations slider reprennent');

            gsap.getTweensOf(sliderSection.querySelectorAll('*')).forEach(tween => {
              tween.play();
            });

          } else {
            // console.log('‚è∏Ô∏è #achivement n\'est plus visible - Mise en pause slider');

            gsap.getTweensOf(sliderSection.querySelectorAll('*')).forEach(tween => {
              tween.pause();
            });
          }
        });
      }, {
        rootMargin: '0px',
        threshold: 0.1
      });

      observer.observe(achievementElement);
      // console.log('üëÄ Observer activ√© pour #achivement (slider pause uniquement)');
    } else {
      console.log('‚ùå √âl√©ment #achivement ou .section_achivement non trouv√©');
    }
  }, 500);
});


// This file was generated by Slater.app - reset_component_badge.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {

  function resetBadgeAnimation(badge) {
    // console.log('üîÑ Badge n\'est plus visible - Animation reset');
    badge.style.setProperty('--animation-state', 'none');
    const pseudoBefore = badge.querySelector('::before');

    badge.classList.add('pause-animation');
  }

  // Fonction pour d√©marrer l'animation d'un badge
  function startBadgeAnimation(badge) {
    // console.log('üé¨ Badge est visible - Animation d√©marr√©e');
    badge.classList.remove('pause-animation');
    // Force reflow
    badge.offsetHeight;
  }

  // S√©lectionner tous les badges radiaux
  const badges = document.querySelectorAll(
    '.badge_radial.is-top-left, .badge_radial.is-bottom-right');

  if (badges.length > 0) {
    // console.log(`üëÄ ${badges.length} badge(s) trouv√©(s)`);

    badges.forEach(badge => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startBadgeAnimation(badge);
          } else {
            resetBadgeAnimation(badge);
          }
        });
      }, {
        rootMargin: '50px',
        threshold: 0
      });

      observer.observe(badge);
    });
  } else {
    // console.log('‚ùå Aucun badge radial trouv√©');
  }

  // Ajouter le style pour la pause
  const style = document.createElement('style');
  style.textContent = `
    .badge_radial.pause-animation.is-top-left::before {
      animation: none !important;
    }
    .badge_radial.pause-animation.is-bottom-right::before {
      animation: none !important;
    }
  `;
  document.head.appendChild(style);

  // Kill et restart les animations au resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);

    // D√©sactive temporairement toutes les animations
    badges.forEach(badge => {
      badge.classList.add('pause-animation');
    });

    // Restart apr√®s un court d√©lai
    resizeTimeout = setTimeout(() => {
      badges.forEach(badge => {
        badge.classList.remove('pause-animation');
        badge.offsetHeight;
      });
    }, 100);
  });
});


// This file was generated by Slater.app - reset_component_btn.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les boutons avec bordure anim√©e
  const btnBorders = document.querySelectorAll('.btn_border');

  if (btnBorders.length > 0) {
    // console.log(`üëÄ ${btnBorders.length} bouton(s) avec bordure anim√©e trouv√©(s)`);

    const style = document.createElement('style');
    style.textContent = `
      .btn_border.pause-animation::before {
        animation: none !important;
      }
    `;
    document.head.appendChild(style);

    // Cr√©er un observer pour chaque bouton
    btnBorders.forEach(btn => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // console.log('üé¨ Bouton est visible - Animation bordure d√©marr√©e');
            btn.classList.remove('pause-animation');
            // Force reflow
            btn.offsetHeight;
          } else {
            // console.log('üîÑ Bouton n\'est plus visible - Animation bordure reset');
            btn.classList.add('pause-animation');
            // Force reflow pour reset
            btn.offsetHeight;
            btn.classList.remove('pause-animation');
            btn.offsetHeight;
          }
        });
      }, {
        rootMargin: '50px',
        threshold: 0
      });

      observer.observe(btn);
    });
  } else {
    // console.log('‚ùå Aucun bouton avec bordure anim√©e trouv√©');
  }

  // Kill et restart les animations au resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);

    // D√©sactive temporairement toutes les animations
    btnBorders.forEach(btn => {
      btn.classList.add('pause-animation');
    });

    // Restart apr√®s un court d√©lai
    resizeTimeout = setTimeout(() => {
      btnBorders.forEach(btn => {
        btn.classList.remove('pause-animation');
        btn.offsetHeight;
      });
    }, 100);
  });
});


// This file was generated by Slater.app - reset_cta_comet.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les segments de com√®te
  const cometSegments = document.querySelectorAll(
    '.comet-segment-1, .comet-segment-2, .comet-segment-3, .comet-segment-4'
  );

  if (cometSegments.length > 0) {
    // console.log(`üëÄ ${cometSegments.length} segment(s) de com√®te trouv√©(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #cta n\'est plus visible - Animations com√®tes reset');
      cometSegments.forEach(segment => {
        segment.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #cta est visible - Animations com√®tes d√©marr√©es');
      cometSegments.forEach(segment => {
        // Force reflow pour reset l'animation
        segment.offsetHeight;
        segment.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #cta
    const ctaElement = document.querySelector('#cta');

    if (ctaElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(ctaElement);
      // console.log('üëÄ Observer activ√© pour #cta (com√®tes)');
    } else {
      console.log('‚ùå √âl√©ment #cta non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      cometSegments.forEach(segment => {
        segment.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        cometSegments.forEach(segment => {
          segment.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun segment de com√®te trouv√©');
  }
});


// This file was generated by Slater.app - reset_footer_comet.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  let isAnimating = false;

  function resetAnimations() {
    const comets = document.querySelectorAll(
      '.footer_comet-1, .footer_comet-2, .footer_comet-3');
    comets.forEach(comet => {
      comet.style.animation = 'none';
    });
    isAnimating = false;
  }

  function startAnimations() {
    const comets = document.querySelectorAll(
      '.footer_comet-1, .footer_comet-2, .footer_comet-3');
    comets.forEach(comet => {
      // Force reflow pour reset l'animation
      comet.offsetHeight;
      comet.style.animation = '';
    });
    isAnimating = true;
  }

  // Configurer l'IntersectionObserver pour le footer
  const footerElement = document.querySelector('footer');

  if (footerElement) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          startAnimations();
        } else {
          resetAnimations();
        }
      });
    }, {
      rootMargin: '0px'
    });

    observer.observe(footerElement);
  }

  // Kill et restart les animations au resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);

    const comets = document.querySelectorAll(
      '.footer_comet-1, .footer_comet-2, .footer_comet-3');

    // D√©sactive les animations
    comets.forEach(comet => {
      comet.style.animation = 'none';
    });

    // Restart apr√®s un court d√©lai
    resizeTimeout = setTimeout(() => {
      comets.forEach(comet => {
        comet.style.animation = '';
      });
    }, 100);
  });
});


// This file was generated by Slater.app - reset_process_cursor-translate.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner les √©l√©ments du curseur de conversion
  const cursorElements = document.querySelectorAll(
    '[cursor="conversion-cursor-wrapper"], [cursor="conversion-cursor-rotate"]'
  );

  if (cursorElements.length > 0) {
    // console.log(`üëÄ ${cursorElements.length} √©l√©ment(s) de curseur trouv√©(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #process n\'est plus visible - Animations curseur reset');
      cursorElements.forEach(element => {
        element.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #process est visible - Animations curseur d√©marr√©es');
      cursorElements.forEach(element => {
        // Force reflow pour reset l'animation
        element.offsetHeight;
        element.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #process
    const processElement = document.querySelector('#process');

    if (processElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(processElement);
      // console.log('üëÄ Observer activ√© pour #process (curseur)');
    } else {
      console.log('‚ùå √âl√©ment #process non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      cursorElements.forEach(element => {
        element.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        cursorElements.forEach(element => {
          element.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun √©l√©ment de curseur trouv√©');
  }
});


// This file was generated by Slater.app - reset_process_navigator.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les √©l√©ments navigator
  const navigatorElements = document.querySelectorAll(
    '[navigator^="bg-"], [navigator^="blue-"]');

  // S√©lectionner aussi les fl√®ches √† l'int√©rieur des blue-1, blue-2, blue-3
  const arrowElements = document.querySelectorAll(
    '[navigator="blue-1"] [navigator="arrow"], [navigator="blue-2"] [navigator="arrow"]'
  );

  const allElements = [...navigatorElements, ...arrowElements];

  if (allElements.length > 0) {
    // console.log(`üëÄ ${allElements.length} √©l√©ment(s) navigator trouv√©(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #process n\'est plus visible - Animations navigator reset');
      allElements.forEach(element => {
        element.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #process est visible - Animations navigator d√©marr√©es');
      allElements.forEach(element => {
        // Force reflow pour reset l'animation
        element.offsetHeight;
        element.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #process
    const processElement = document.querySelector('#process');

    if (processElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(processElement);
      // console.log('üëÄ Observer activ√© pour #process (navigator)');
    } else {
      console.log('‚ùå √âl√©ment #process non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      allElements.forEach(element => {
        element.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        allElements.forEach(element => {
          element.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun √©l√©ment navigator trouv√©');
  }
});


// This file was generated by Slater.app - reset_process_palette.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les items de palette
  const paletteItems = document.querySelectorAll('.process_grid-palette-item');

  if (paletteItems.length > 0) {
    // console.log(`üëÄ ${paletteItems.length} item(s) de palette trouv√©(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #process n\'est plus visible - Animations palette reset');
      paletteItems.forEach(item => {
        item.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #process est visible - Animations palette d√©marr√©es');
      paletteItems.forEach(item => {
        // Force reflow pour reset l'animation
        item.offsetHeight;
        item.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #process
    const processElement = document.querySelector('#process');

    if (processElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(processElement);
      // console.log('üëÄ Observer activ√© pour #process (palette)');
    } else {
      console.log('‚ùå √âl√©ment #process non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      paletteItems.forEach(item => {
        item.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        paletteItems.forEach(item => {
          item.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun item de palette trouv√©');
  }
});


// This file was generated by Slater.app - reset_process_paper.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les √©l√©ments skeleton
  const skeletonElements = document.querySelectorAll('[class*="process_skeleton"]');

  if (skeletonElements.length > 0) {
    // console.log(`üëÄ ${skeletonElements.length} √©l√©ment(s) skeleton trouv√©(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #process n\'est plus visible - Animations skeleton reset');
      skeletonElements.forEach(element => {
        element.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #process est visible - Animations skeleton d√©marr√©es');
      skeletonElements.forEach(element => {
        // Force reflow pour reset l'animation
        element.offsetHeight;
        element.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #process
    const processElement = document.querySelector('#process');

    if (processElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(processElement);
      // console.log('üëÄ Observer activ√© pour #process (skeleton)');
    } else {
      console.log('‚ùå √âl√©ment #process non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      skeletonElements.forEach(element => {
        element.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        skeletonElements.forEach(element => {
          element.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun √©l√©ment skeleton trouv√©');
  }
});


// This file was generated by Slater.app - reset_process_screen.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les √©l√©ments anim√©s de la grille process
  const processGridElements = document.querySelectorAll(
    '.process_grid-line, .process_grid-block.is-1, .process_grid-block.is-2, .process_grid-block.is-3, .process_grid-block.is-4, .process_grid-block.is-5, .process_grid-block.is-6, .process_grid-block.is-7, .process_grid-block.is-8'
  );

  // S√©lectionner aussi les rect √† l'int√©rieur de is-6 pour l'animation stroke
  const processGridRects = document.querySelectorAll('.process_grid-block.is-6 rect');

  const allElements = [...processGridElements, ...processGridRects];

  if (allElements.length > 0) {
    // console.log(`üëÄ ${allElements.length} √©l√©ment(s) de grille process trouv√©(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #process n\'est plus visible - Animations grille reset');
      allElements.forEach(element => {
        element.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #process est visible - Animations grille d√©marr√©es');
      allElements.forEach(element => {
        // Force reflow pour reset l'animation
        element.offsetHeight;
        element.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #process
    const processElement = document.querySelector('#process');

    if (processElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(processElement);
      // console.log('üëÄ Observer activ√© pour #process (grille)');
    } else {
      console.log('‚ùå √âl√©ment #process non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      allElements.forEach(element => {
        element.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        allElements.forEach(element => {
          element.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun √©l√©ment de grille process trouv√©');
  }
});


// This file was generated by Slater.app - reset_service_comet.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner toutes les com√®tes de service
  const serviceComets = document.querySelectorAll('.service_comet-light');

  if (serviceComets.length > 0) {
    // console.log(`üëÄ ${serviceComets.length} com√®te(s) de service trouv√©e(s)`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #service n\'est plus visible - Animations com√®tes service reset');
      serviceComets.forEach(comet => {
        comet.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #service est visible - Animations com√®tes service d√©marr√©es');
      serviceComets.forEach(comet => {
        // Force reflow pour reset l'animation
        comet.offsetHeight;
        comet.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #service
    const serviceElement = document.querySelector('#service');

    if (serviceElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(serviceElement);
      // console.log('üëÄ Observer activ√© pour #service (com√®tes service)');
    } else {
      console.log('‚ùå √âl√©ment #service non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      serviceComets.forEach(comet => {
        comet.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        serviceComets.forEach(comet => {
          comet.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucune com√®te de service trouv√©e');
  }
});


// This file was generated by Slater.app - reset_service_dash.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // S√©lectionner tous les √©l√©ments avec animations dash pour #service
  const serviceDashElements = document.querySelectorAll(
    '[webflow-dash=""], [n8n-dash=""], [n8n-dash="reverse"], .process_bento-path, [compo-dash=""]'
  );

  if (serviceDashElements.length > 0) {
    // console.log(`üëÄ ${serviceDashElements.length} √©l√©ment(s) dash trouv√©(s) pour #service`);

    let isAnimating = false;

    function resetAnimations() {
      // console.log('üîÑ #service n\'est plus visible - Animations dash reset');
      serviceDashElements.forEach(element => {
        element.style.animation = 'none';
      });
      isAnimating = false;
    }

    function startAnimations() {
      // console.log('üé¨ #service est visible - Animations dash d√©marr√©es');
      serviceDashElements.forEach(element => {
        // Force reflow pour reset l'animation
        element.offsetHeight;
        element.style.animation = '';
      });
      isAnimating = true;
    }

    // Configurer l'IntersectionObserver pour #service
    const serviceElement = document.querySelector('#service');

    if (serviceElement) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startAnimations();
          } else {
            resetAnimations();
          }
        });
      }, {
        rootMargin: '100px'
      });

      observer.observe(serviceElement);
      // console.log('üëÄ Observer activ√© pour #service (tous les dash)');
    } else {
      console.log('‚ùå √âl√©ment #service non trouv√©');
    }

    // Kill et restart les animations au resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);

      // D√©sactive les animations
      serviceDashElements.forEach(element => {
        element.style.animation = 'none';
      });

      // Restart apr√®s un court d√©lai
      resizeTimeout = setTimeout(() => {
        serviceDashElements.forEach(element => {
          element.style.animation = '';
        });
      }, 100);
    });
  } else {
    console.log('‚ùå Aucun √©l√©ment dash trouv√© pour #service');
  }
});


// This file was generated by Slater.app - service_bubble-hotjar-anim.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  gsap.registerPlugin(MotionPathPlugin);

  const selectorsGroup1 = [
    '.service_bento-glass-hotjar.is-devis',
    '.service_bento-glass-hotjar.is-leads',
    '.service_bento-glass-hotjar.is-interaction',
    '.service_bento-glass-hotjar.is-visitor',
    '.service_bento-glass-hotjar.is-money',
    '.service_bento-glass-hotjar.is-devis-2',
    '.service_bento-glass-hotjar.is-leads-2',
    '.service_bento-glass-hotjar.is-interaction-2',
    '.service_bento-glass-hotjar.is-visitor-2',
    '.service_bento-glass-hotjar.is-money-2'
  ];

  const selectorsGroup2 = [
    '.service_bento-glass-hotjar.is-devis.is-2',
    '.service_bento-glass-hotjar.is-leads.is-2',
    '.service_bento-glass-hotjar.is-interaction.is-2',
    '.service_bento-glass-hotjar.is-visitor.is-2',
    '.service_bento-glass-hotjar.is-money.is-2',
    '.service_bento-glass-hotjar.is-devis-2.is-2',
    '.service_bento-glass-hotjar.is-leads-2.is-2',
    '.service_bento-glass-hotjar.is-interaction-2.is-2',
    '.service_bento-glass-hotjar.is-visitor-2.is-2',
    '.service_bento-glass-hotjar.is-money-2.is-2'
  ];

  const animDuration = 20;
  let cursorTweens = [];
  let isAnimating = false;

  function createAnimations() {
    // Tuer les animations existantes
    cursorTweens.forEach(tw => tw.kill());
    cursorTweens = [];

    const windowWidth = window.innerWidth;

    if (windowWidth >= 992) {
      // Animer le premier groupe
      selectorsGroup1.forEach((sel, i) => {
        const els = document.querySelectorAll(sel);
        els.forEach(el => {
          const startPos = i / selectorsGroup1.length;
          const tween = gsap.to(el, {
            motionPath: {
              path: "#bento-path",
              align: "#bento-path",
              alignOrigin: [0.5, 0.5],
              autoRotate: false,
              start: startPos,
              end: startPos - 1
            },
            rotation: 0,
            duration: animDuration,
            ease: "linear",
            repeat: -1,
            repeatDelay: 0
          });
          cursorTweens.push(tween);
        });
      });
    } else {
      // Animer le second groupe
      selectorsGroup2.forEach((sel, i) => {
        const els = document.querySelectorAll(sel);
        els.forEach(el => {
          const startPos = i / selectorsGroup2.length;
          const tween = gsap.to(el, {
            motionPath: {
              path: "#bento-path-2",
              align: "#bento-path-2",
              alignOrigin: [0.5, 0.5],
              autoRotate: false,
              start: startPos,
              end: startPos - 1
            },
            rotation: 0,
            duration: animDuration,
            ease: "linear",
            repeat: -1,
            repeatDelay: 0
          });
          cursorTweens.push(tween);
        });
      });
    }

    isAnimating = true;
  }

  function stopAnimations() {
    cursorTweens.forEach(tw => tw.pause());
    isAnimating = false;
  }

  function resumeAnimations() {
    cursorTweens.forEach(tw => tw.resume());
    isAnimating = true;
  }

  // Configurer l'IntersectionObserver
  const serviceElement = document.querySelector('#service');

  if (serviceElement) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // console.log('üé¨ #service est visible - Animation d√©marr√©e');
          if (!isAnimating) {
            if (cursorTweens.length === 0) {
              createAnimations();
            } else {
              resumeAnimations();
            }
          }
        } else {
          // console.log('‚è∏Ô∏è #service n\'est plus visible - Animation en pause');
          if (isAnimating) {
            stopAnimations();
          }
        }
      });
    }, {
      rootMargin: '0px' // D√©marre l'animation 100px avant que l'√©l√©ment soit visible
    });

    observer.observe(serviceElement);
  }

  // Recr√©er les animations au redimensionnement
  window.addEventListener('resize', () => {
    if (isAnimating) {
      createAnimations();
    }
  });
});


// This file was generated by Slater.app - service_conversion-graph.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  gsap.registerPlugin(MotionPathPlugin);

  const paths = [
    "#conversion-path-1",
    "#conversion-path-2",
    "#conversion-path-3",
    "#conversion-path-4"
  ];

  const totalCssDuration = 24.5; // Dur√©e totale du cycle CSS
  const pathDuration = totalCssDuration / 4; // ~6.125s par path
  const animDuration = 4.625; // Dur√©e de l'animation
  const waitDuration = 1.5; // Dur√©e d'attente

  let currentIndex = 0;
  let cursorTween;
  let waitingTimeout;
  let isAnimating = false;

  const animatedElements = [
    'gradient-fill-conversion',
    'dashed-conversion-1',
    'dashed-conversion-2',
    'dashed-conversion-3',
    'dashed-conversion-4',
    'dashed-conversion-5',
    'dashed-conversion-6',
    'dashed-conversion-7',
    'line-conversion-1',
    'line-conversion-2',
    'line-conversion-3',
    'line-conversion-4',
    'line-conversion-5',
    'line-conversion-6',
    'line-conversion-7'
  ];

  function animateCursorOnPath(index) {
    gsap.killTweensOf("#conversion-cursor");
    const path = paths[index];

    cursorTween = gsap.to("#conversion-cursor", {
      motionPath: {
        path: path,
        align: path,
        alignOrigin: [0.5, 0.5],
        autoRotate: true
      },
      duration: animDuration,
      ease: "cubic-bezier(0.6, 0.04, 0.98, 0.34)",
      onComplete: () => {
        if (isAnimating) {
          waitingTimeout = setTimeout(() => {
            currentIndex = (currentIndex + 1) % paths.length;
            animateCursorOnPath(currentIndex);
          }, waitDuration * 1000);
        }
      }
    });
  }

  function startAnim() {
    if (!isAnimating) {
      // console.log('üé¨ #service est visible - Animation curseur d√©marr√©e');
      isAnimating = true;

      // Reset et d√©marre les animations CSS
      animatedElements.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          // Force le reset
          el.style.animation = 'none';
          void el.offsetHeight; // Force reflow
          el.style.animation = '';
        }
      });

      // Reset l'index et d√©marre GSAP
      currentIndex = 0;
      animateCursorOnPath(currentIndex);
    }
  }

  function stopAnim() {
    if (isAnimating) {
      // console.log('üîÑ #service n\'est plus visible - Animation curseur reset');
      isAnimating = false;

      // Kill l'animation GSAP
      if (cursorTween) cursorTween.kill();
      clearTimeout(waitingTimeout);

      // Reset les animations CSS
      animatedElements.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.style.animation = 'none';
        }
      });

      // Reset le curseur √† la position initiale
      gsap.set("#conversion-cursor", { clearProps: "all" });

      // Reset l'index
      currentIndex = 0;
    }
  }

  function restartAnim() {
    // console.log('üîÑ Resize - Restart animations curseur');
    if (cursorTween) cursorTween.kill();
    clearTimeout(waitingTimeout);
    currentIndex = 0;
    if (isAnimating) {
      animateCursorOnPath(currentIndex);
    }
  }

  // Configurer l'IntersectionObserver
  const serviceElement = document.querySelector('#service');

  if (serviceElement) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          startAnim();
        } else {
          stopAnim();
        }
      });
    }, {
      rootMargin: '100px'
    });

    observer.observe(serviceElement);
    // console.log('üëÄ Observer activ√© pour #service (curseur conversion)');
  } else {
    console.log('‚ùå √âl√©ment #service non trouv√© (curseur conversion)');
  }

  // Kill et restart les animations au resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);

    console.log('üîÑ Resize d√©tect√© - Pause animations curseur');

    // D√©sactive les animations CSS
    animatedElements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.animation = 'none';
      }
    });

    // Restart apr√®s un court d√©lai
    resizeTimeout = setTimeout(() => {
      console.log('‚ñ∂Ô∏è Resize - Restart animations curseur');

      // Restart animations CSS
      animatedElements.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          void el.offsetHeight;
          el.style.animation = '';
        }
      });

      // Restart animation GSAP
      restartAnim();
    }, 100);
  });
});

// window.Webflow = window.Webflow || [];
// window.Webflow.push(function () {
//   gsap.registerPlugin(MotionPathPlugin);

//   const paths = [
//     "#conversion-path-1",
//     "#conversion-path-2",
//     "#conversion-path-3",
//     "#conversion-path-4"
//   ];

//   const totalCssDuration = 24.5; // Dur√©e totale du cycle CSS
//   const pathDuration = totalCssDuration / 4; // ~6.125s par path
//   const animDuration = 4.625; // Dur√©e de l'animation
//   const waitDuration = 1.5; // Dur√©e d'attente

//   let currentIndex = 0;
//   let cursorTween;
//   let waitingTimeout;

//   function animateCursorOnPath(index) {
//     gsap.killTweensOf("#conversion-cursor");
//     const path = paths[index];

//     cursorTween = gsap.to("#conversion-cursor", {
//       motionPath: {
//         path: path,
//         align: path,
//         alignOrigin: [0.5, 0.5],
//         autoRotate: true
//       },
//       duration: animDuration,
//       ease: "cubic-bezier(0.6, 0.04, 0.98, 0.34)", // M√™me easing que CSS
//       onComplete: () => {
//         waitingTimeout = setTimeout(() => {
//           currentIndex = (currentIndex + 1) % paths.length;
//           animateCursorOnPath(currentIndex);
//         }, waitDuration * 1000);
//       }
//     });
//   }

//   function restartAnim() {
//     if (cursorTween) cursorTween.kill();
//     clearTimeout(waitingTimeout);
//     animateCursorOnPath(currentIndex = 0);
//   }

//   animateCursorOnPath(currentIndex);

//   let resizeTimeout;
//   window.addEventListener('resize', () => {
//     clearTimeout(resizeTimeout);
//     resizeTimeout = setTimeout(restartAnim, 100);
//   });
// });


// This file was generated by Slater.app - service_conversion-rm-resize.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  const animatedElements = [
    'gradient-fill-conversion',
    'dashed-stroke-conversion',
    'dashed-conversion-1',
    'dashed-conversion-2',
    'dashed-conversion-3',
    'dashed-conversion-4',
    'dashed-conversion-5',
    'dashed-conversion-6',
    'dashed-conversion-7',
    'line-conversion-1',
    'line-conversion-2',
    'line-conversion-3',
    'line-conversion-4',
    'line-conversion-5',
    'line-conversion-6',
    'line-conversion-7'
  ];
  
  let isAnimating = false;
  
  function pauseAnimations() {
    animatedElements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.animation = 'none';
      }
    });
    isAnimating = false;
  }
  
  function resumeAnimations() {
    animatedElements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        // Force reflow pour reset l'animation
        el.offsetHeight;
        el.style.animation = '';
      }
    });
    isAnimating = true;
  }
  
  // Configurer l'IntersectionObserver
  const serviceElement = document.querySelector('#service');
  
  if (serviceElement) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          resumeAnimations();
        } else {
          pauseAnimations();
        }
      });
    }, {
      rootMargin: '0px'
    });
    
    observer.observe(serviceElement);
  }
  
  // Kill et restart les animations CSS au resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    
    // D√©sactive les animations
    animatedElements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.animation = 'none';
      }
    });
    
    // Restart apr√®s un court d√©lai
    resizeTimeout = setTimeout(() => {
      animatedElements.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.style.animation = '';
        }
      });
    }, 100);
  });
});

// This file was generated by Slater.app - service_hotjar-rm-resize.js


window.Webflow = window.Webflow || [];
window.Webflow.push(function () {
  // Fonction pour obtenir les bons IDs selon la largeur d'√©cran
  function getAnimatedElements() {
    const isTablet = window.innerWidth < 992;
    const suffix = isTablet ? '_tablet' : '';

    return [
      // Chemins pointill√©s
      `dashed-path-1${suffix}`,
      `dashed-corner-1${suffix}`,
      `dashed-path-2${suffix}`,
      `dashed-corner-2${suffix}`,
      `dashed-path-3${suffix}`,
      `dashed-corner-3${suffix}`,
      `dashed-path-4${suffix}`,
      `dashed-corner-4${suffix}`,
      `dashed-path-5${suffix}`,
      `dashed-corner-5${suffix}`,
      `dashed-path-6${suffix}`,
      `dashed-corner-6${suffix}`,
      `dashed-path-7${suffix}`,
      // Chemins pleins
      `line-path-9${suffix}`,
      `line-corner-8${suffix}`,
      `line-path-8${suffix}`,
      `line-corner-7${suffix}`,
      `line-path-7${suffix}`,
      `line-corner-6${suffix}`,
      `line-path-6${suffix}`,
      `line-corner-5${suffix}`,
      `line-path-5${suffix}`,
      `line-corner-4${suffix}`,
      `line-path-4${suffix}`,
      `line-corner-3${suffix}`,
      `line-path-3${suffix}`,
      `line-corner-2${suffix}`,
      `line-path-2${suffix}`,
      `line-corner-1${suffix}`,
      `line-path-1${suffix}`,
      // Remplissage principal (gradient) si anim√© via CSS
      `gradient-fill${suffix}`
    ];
  }

  let isAnimating = false;

  function resetAnimations() {
    const elements = getAnimatedElements();
    elements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.animation = 'none';
      }
    });
    isAnimating = false;
  }

  function startAnimations() {
    const elements = getAnimatedElements();
    elements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        // Force reflow pour reset l'animation
        el.offsetHeight;
        el.style.animation = '';
      }
    });
    isAnimating = true;
  }

  // Configurer l'IntersectionObserver
  const serviceElement = document.querySelector('#service');

  if (serviceElement) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          startAnimations();
        } else {
          resetAnimations();
        }
      });
    }, {
      rootMargin: '0px'
    });

    observer.observe(serviceElement);
  }

  // Kill et restart les animations CSS au resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);

    // Kill les animations CSS
    const elements = getAnimatedElements();
    elements.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.animation = 'none';
      }
    });

    // Relance les animations apr√®s un court d√©lai
    resizeTimeout = setTimeout(() => {
      const elements = getAnimatedElements();
      elements.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.style.animation = '';
        }
      });
    }, 100);
  });
});


